---
layout: page
title: Node.js
subtitle : 
---
	<div class="box alt">
		<div class="row uniform 50%">
			<div class="12u"><span class="image fit"><img src="images/nodejs-main.svg" alt="" /></span></div>
		</div>
	</div>

	<h3>Node.js 소개</h3>
	<p>Node.js는 비동기 이벤트 주도 JavaScript 런타임으로써 확장성 있는 네트워크 애플리케이션을 만들 수 있도록 설계되었다.</p>
	<a href="https://nodejs.org/ko/about/">https://nodejs.org/ko/about/</a>
	<hr/>

	<h3>Node.js의 특징</h3>
	<ul class="alt">
		<li><h5>비동기 I/O 처리 / 이벤트 위주</h5>Node.js 라이브러리의 모든 API는 비동기식(Non-blocking).<br/> Node.js 기반 서버는 API가 실행되었을때, 데이터를 반환할때까지 기다리지 않고 다음 API 를 실행합니다. 그리고 이전에 실행했던 API가 결과값을 반환할 시, NodeJS의 이벤트 알림 메커니즘을 통해 결과값을 받아옵니다.</li>
		<li><h5>빠른 속도</h5>구글 크롬 V8 자바스크립트 엔진을 사용하여 빠른 코드 실행을 제공</li>
		<li><h5>단일 쓰레드 / 뛰어난 확장성</h5>Node.js는 이벤트 루프와 함께 단일 쓰레드 모델을 사용.<br/>이벤트 메커니즘은 서버가 멈추지않고 반응하도록 해주어 서버의 확장성을 키워줍니다.  반면,  일반적인 웹서버는 (Apache) 요청을 처리하기 위하여 제한된 쓰레드를 생성합니다. Node.js 는 쓰레드를 한개만 사용하고  Apache 같은 웹서버보다 훨씬 많은 요청을 처리할 수 있습니다.</li>
		<li><h5>노 버퍼링</h5>Node.js application엔 데이터 버퍼링이 없고, 데이터를 chunk로 출력</li>
		<li><h5>라이센스</h5>Node.js 는 MIT License가 적용되어있습니다.</li>
	</ul>
	<hr/>

	<h3>Node.js가 사용되면 효율적인 분야</h3>
	<ul>
		<li>입출력이 잦은 어플리케이션</li>
		<li>데이터 스트리밍 어플리케이션</li>
		<li>데이터를 실시간으로 다루는 어플리케이션</li>
		<li>JSON API 기반 어플리케이션</li>
		<li>싱글페이지 어플리케이션</li>
	</ul>

	<h3>Node.js 비효율적인 분야</h3>
	<ul>
		<li>cpu 사용률이 높은 어플리케이션</li>
	</ul>
	<hr/>

	<h3>Node.js 설치</h3>
	<p><a href="https://nodejs.org/ko/">https://nodejs.org/ko</a> 에서 LTS 버젼 설치</p>
	<div class="box alt">
		<div class="row uniform 50%">
			<div class="12u"><span class="image fit"><img src="images/nodejs01.png" alt="" /></span></div>
		</div>
	</div>
	<p>LTS(Long Term Supported)버젼은 장기적으로 안정된지원이 보장</p>
	<p>Current버젼은 최신기능을 제공하지만 지속적인 업데이트로 안정적이지 않을수 있다.</p>
	<p>node.js 설치시 npm도 같이 설치되며 CMD(명령 프롬프트)에서 설치를 확인할수 있다.</p>
	<pre><code>> node -v
v12.2.0

> npm -v
6.9.0</code></pre>
	<hr/>

	<h3>NPM(Node Package Manager)</h3>
	<p>Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI(Command line interface)를 제공한다.</p>
	<p>자신이 작성한 패키지를 공개할 수도 있고 필요한 패키지를 검색하여 재사용할 수도 있다.</p>
	<pre><code>> npm intall <-package>

> npm i <-package></code></pre>
	<p>install 명령어중 별도의 옵션을 지정하지않으면 지역(local)으로 설치되며, -g 옵션을 지정하면 전역(global)으로 설치된다.</p>
	<pre><code>> npm i -g <-package></code></pre>
	<hr/>

	<h3>package.json과 의존성 관리</h3>
	<p>node.js 프로젝트에서는 많은 패키지를 사용하게 되고 패키지의 버젼도 빈번하게 업데이트 되므로 프로젝트가 의존하고 있는 패키지를 일괄 관리 할 필요가 있다.<br/>
	npm은 packge.json 파일을 통해서 프로젝트 정보와 패키지의 의존성(dependency)을 관리한다.
	이미 작성된 package.json이 있다면 팀 내에 배포하여 동일한 개발 환경을 빠르게 구축할수 있는 장점이 있다.<br/>
	package.json은 Java의 maven에서 pom.xml과 비슷한 역할을 한다.</p>
	<p>devDependencies에는 개발 시에만 사용하는 개발용 의존 패키지를 명시한다.<br/>
	예를 들어 TypeScript와 같은 트랜스파일러는 개발 단계에서만 필요하고 배포할 필요는 없으므로 devDependencies에 포함시킨다.<br/>
	npm install 명령어에 --save-dev(축약형 -D) 옵션을 사용하면 패키지 설치와 함께 package.json의 devDependencies에 설치된 패키지와 버전이 기록된다.</p>
	<pre><code>> npm i -D <-package>
	
// package.json
"devDependencies": {
	"-package": "@version"
}
</code></pre>
	<hr/>

	<h3>자주 사용하는 npm 명령어</h3>
	<p>package.json 생성</p>
	<pre><code>> npm init

// 기본설정
> npm init -y</code></pre>
	<p>패키지 설치</p>
	<pre><code>//로컬 설치
> npm install <-package>

// 전역 설치
> npm install -g <-package>

// 개발 설치
> npm install -D <-package></code></pre>
	<p>패키지 제거</p>
	<pre><code>// 로컬/개발 패키지 제거
> npm uninstall <-package>

// 전역 패키지 제거
> npm uninstall -g -<package></code></pre>
	<p>패키지 업데이트</p>
	<pre><code>> npm update <-package></code></pre>
	<p>package.json scripts 프로퍼티의 start 실행</p>
	<pre><code>> npm start</code></pre>
	<p>package.json scripts 프로퍼티의 start 이외의 scripts 실행</p>
	<pre><code>> npm run <-script-name></code></pre>
	<p>전역 패키지 설치 폴더 확인</p>
	<pre><code>> npm root -g</code></pre>
	<p>패키지 정보 참조</p>
	<pre><code>> npm view <-script-name></code></pre>
	<hr/>
	
	<h3>Node.js Application 만들기</h3>
	<header><h5>1단계 필요한 모듈 import하기</h5></header>
	<p>어플리케이션에 필요한 모듈을 불러올땐 require 명령을 사용합니다.<br/>
		다음 코드는 HTTP 모듈을불러오고 반환되는 HTTP 인스턴스를 http 변수에 저장합니다.</p>
	<pre><code>var http = require("http");</code></pre>

	<header><h5>2단계 서버 생성하기</h5></header>
	<p>1단계에서 만든 http 인스턴스를 사용하여 http.createServer() 메서드를 실행<br/>
	listen 메서드를 사용하여 포트8081과 bind 해준다.<br/>
	http.createServer()는 request와 response를 매개변수로 함수가 실행된다.</p>
	<pre><code>http.createServer(function(request, response){
	/* 
		HTTP 헤더 전송
		HTTP Status: 200 : OK
		Content Type: text/plain
	*/
	response.writeHead(200, {'Content-Type': 'text/plain'});

	/*
		Response Body 를 "Hello World" 로 설정
	*/
	response.end("Hello World\n");
}).listen(8081);</code></pre>

	<header><h5>3단계 서버테스트 해보기</h5></header>
	<p>위 1,2 단계로 작성된 main.js를 실행</p>
	<pre><code>> node main.js</code></pre>
	<div class="box alt">
		<div class="row uniform 50%">
			<div class="12u"><span class="image fit"><img src="images/nodejs27.png" alt="" /></span></div>
		</div>
	</div>
	<hr/>

	<h3>callback function</h3>
	<p>javascript에서 function은 일급 객체. 즉, 함수는 Object타입이며 다른 일급 객체(string, arrary, number 등)와 똑같이 사용될수 있다.<br/>
	function 자체가 객체이므로 변수 안에 담을 수 도 있고, 인수로써 다른 함수에 전달 해 줄수도 있고, 함수에서 만들어 질수도 있고, 반환될수도 있다.</p>
	<p>callback function은, 특정함수에 매개변수로써 전달된 함수를 지칭하고, 전달 받은 함수 안에서 호출된다.</p>
	<p>jQuery에서 사용된 callback function 예제</p>
	<pre><code>$("#btn_1").click(function() {
	alert("Btn 1 Clicked");
});
// click 메소드에 이름이 없는 callback function을 인수로 전달
// jQuery 안의 click 메소드에서는, 마우스 클릭이 있으면 callback function을 호출</code></pre>
	<p>click 메소드의 인수가 함수. 이함수가 callback function.</p>
	
	<h5>callback function이 많이 사용되는 이유</h5>
	<p>callback function이 사용되지않은, blocking code 예제</p>
	<pre><code>// input.txt
Let's understand what is a callback function.
What the HELL is it?

// main.js
var fs = require("fs");

var data = fs.readFileSync('input.txt');

console.log(data.toString());
console.log("Program has ended");

// node main.js
Let's understand what is a callback function.
What the HELL is it?
Program has ended</code></pre>

	<p>Callback function이 사용된 Non-Blocking Code 예제</p>
	<p>blocking code예제와 다르게 function이 실행될때 종료를 기다리지 않고 다음 코드를 실행하고 <br/>
		function에 있던 작업이 끝나면 callback function을 호출한다.</p>
	<pre><code>// main.js 수정
var fs = require("fs");

fs.readFile('input.txt', function (err, data) {
	if (err) return console.error(err);
	console.log(data.toString());
});

console.log("Program has ended");

// node main.js
Program has ended
Let's understand what is a callback function.
What the HELL is it?</code></pre>

	<p>모든 node application의 비동기식 함수에서는 첫번째 매개변수로는 error를 마지막 매개변수로는 callback function을 받는다.</p>
	<p>fs.readFile() 함수는 비동기식으로 파일을 읽는 함수이고, 도중에 error가 발생하면 err객체에 내용을 담고, 정상흐름이면 파일내용을 읽고 출력.<br/>
	readFile() 메서드가 실행 된후, 프로그램이 메소드가 끝날때까지 대기하지않고, 곧바로 다음 명령어를 진행 하였기 때문에, "Program has ended"가 먼저 출력된다.</p>
	<p>callback function을 사용하여 이렇게 프로그램의 흐름을 끊지 않음으로서,
		Non-Blocking 코드를 사용하는 서버는 Blocking 코드를 사용하는 서버보다 더 많은 양의 요청을 빠르게 처리 할 수 있게된다.</p>
	<hr/>
	
	<h3>Event Loop</h3>
	<p><a href="https://www.youtube.com/watch?v=gP0J1WZZRr4&t=212s">event loop 기초강의</a><br/></p>
	<h5>call stack</h5>
	<h5>callback queue</h5>
		






	<hr/>
	<h3>Reference</h3>
	<div class="row">
		<div class="6u$ 12u$(medium)">
			<ol>
				<li><a href="https://velopert.com/210">velopert - nodejs</a></li>
				<li><a href="https://poiemaweb.com/nodejs-npm">poiemaweb - nodejs</a></li>
				<li><a href="https://www.youtube.com/channel/UC1LzvduPSKr9puUr-WJo9AA">fast campus</a></li>
				
			</ol>
		</div>
	</div>
	<hr />